# agents/perception_agent/app.py (THREADING MODE VERSION - COMPLETE & FIXED)

# --- Environment Variables ---
from dotenv import load_dotenv
load_dotenv()

# --- Other Imports ---
import os
import asyncio
import logging
import base64
import threading
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from opencv_perception_agent import OpenCVPerceptionAgent
from prisma import Prisma
from predictor import predict_confidence
import socketio
import math

# --- Basic Setup ---
# Get the absolute path of the directory where the script is located
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
# Construct the absolute path to the Next.js static build output directory
FRONTEND_DIR = os.path.join(BASE_DIR, '..', '..', 'frontend', '.next', 'server', 'app')
# Construct the path to the static assets directory
STATIC_DIR = os.path.join(BASE_DIR, '..', '..', 'frontend', '.next', 'static')

# Configure Flask to serve static files from the Next.js build directory
app = Flask(__name__, static_folder=FRONTEND_DIR, static_url_path='/static')
CORS(app)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Socket.IO Integration (THREADING MODE) ---
# Use standard server and threading mode
sio = socketio.Server(cors_allowed_origins="*", async_mode='threading')

# --- Route for Next.js Static Assets ---
# This route is crucial for serving CSS, JS, and other assets
@app.route('/_next/static/<path:filename>')
def serve_next_static(filename):
    """Serves static assets from the Next.js build output."""
    return send_from_directory(STATIC_DIR, filename)

# --- Frontend Routes ---
# These routes serve the HTML pages generated by Next.js build

@app.route('/')
def serve_index():
    """Serves the main index page."""
    return send_from_directory(FRONTEND_DIR, 'index.html')

@app.route('/dashboard')
def serve_dashboard():
    """Serves the dashboard page."""
    return send_from_directory(FRONTEND_DIR, 'dashboard.html')

@app.route('/predict')
def serve_predict():
    """Serves the predict page."""
    return send_from_directory(FRONTEND_DIR, 'predict.html')

@app.route('/swarm')
def serve_swarm():
    """Serves the swarm page."""
    return send_from_directory(FRONTEND_DIR, 'swarm.html')

# --- API Endpoints ---
@app.route('/api-info')
def index():
    """API information."""
    return jsonify({
        "service": "Perception Agent API",
        "version": "1.0.0",
        "description": "AI-powered crop disease detection service",
        "endpoints": {
            "GET /": "Main Index Page",
            "GET /dashboard": "Dashboard Page",
            "GET /predict": "Predictions Page",
            "GET /swarm": "Swarm Page",
            "GET /api-info": "API information",
            "GET /health": "Health check",
            "POST /detect": "Detect disease from uploaded image",
            "POST /detect_base64": "Detect disease from base64 string",
            "POST /predict": "Predict confidence based on disease_type",
            "GET /analytics": "Get analytics data",
            "POST /process_video": "Start video stream processing"
        }
    })

@app.route('/health')
def health_check():
    """Health check endpoint."""
    return jsonify({"status": "healthy", "service": "Perception Agent"}), 200

@app.route('/detect_base64', methods=['POST'])
def detect_disease_base64():
    """Detects disease from a base64 encoded image string."""
    try:
        data = request.get_json()
        if not data or 'image_base64' not in data:
            return jsonify({"error": "image_base64 field is required"}), 400

        image_b64 = data['image_base64']
        agent = OpenCVPerceptionAgent()
        result = agent.detect_disease_base64(image_b64)

        if 'error' not in result:
            try:
                asyncio.run(agent.save_detection_to_db(result))
            except Exception as db_error:
                logger.error(f"Failed to save to DB: {db_error}")

        return jsonify(result), 200

    except Exception as e:
        logger.error(f"Error in detect_disease_base64 endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/detect', methods=['POST'])
def detect_disease_from_file():
    """Detects disease from an uploaded image file."""
    try:
        if 'file' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No selected file"}), 400

        if file:
            img_bytes = file.read()
            img_b64 = base64.b64encode(img_bytes).decode('utf-8')
            agent = OpenCVPerceptionAgent()
            result = agent.detect_disease_base64(img_b64)

            if 'error' not in result:
                try:
                    asyncio.run(agent.save_detection_to_db(result))
                except Exception as db_error:
                    logger.error(f"Failed to save to DB: {db_error}")

            return jsonify(result), 200

    except Exception as e:
        logger.error(f"Error in detect endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/predict', methods=['POST'])
def predict_confidence_endpoint():
    """API endpoint to predict confidence based on disease_type."""
    try:
        data = request.get_json()
        if not data or 'disease_type' not in data:
            return jsonify({"error": "disease_type field is required"}), 400

        disease_type = data['disease_type']
        predicted_confidence = predict_confidence(disease_type)

        if predicted_confidence is None:
            return jsonify({"error": f"Could not make a prediction for '{disease_type}'. The disease type might be unknown or the model is not loaded."}), 400

        result = {
            "disease_type": disease_type,
            "predicted_confidence": round(predicted_confidence, 4)
        }

        return jsonify(result), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/analytics', methods=['GET'])
def get_analytics():
    """Fetches analytics data from the database."""
    try:
        async def fetch_data():
            db = Prisma()
            await db.connect()
            analytics_data = await db.detectionrecord.find_many(
                order={'createdAt': 'desc'},
                take=100
            )
            await db.disconnect()

            disease_counts = {}
            for record in analytics_data:
                disease = record.disease_type
                disease_counts[disease] = disease_counts.get(disease, 0) + 1

            from collections import defaultdict
            time_series_counts = defaultdict(int)
            for record in analytics_data:
                date_str = record.createdAt.strftime('%Y-%m-%d')
                time_series_counts[date_str] += 1

            time_series_data = [{'date': date, 'count': count} for date, count in sorted(time_series_counts.items())]
            return {"recent_detections": [record.model_dump() for record in analytics_data], "disease_counts": disease_counts, "time_series_data": time_series_data}

        result = asyncio.run(fetch_data())
        return jsonify({"status": "success", "data": result}), 200
    except Exception as e:
        logger.error(f"Error in analytics endpoint: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/process_video', methods=['POST'])
def process_video():
    """Endpoint to start processing a video stream."""
    try:
        data = request.get_json()
        video_source = data.get('source', 0)
        def run_processing():
            try:
                from video_processor import VideoProcessor
                processor = VideoProcessor()
                for result in processor.process_video_stream(video_source):
                    print(f"DETECTED: {result}")
            except Exception as e:
                print(f"Error in video processing thread: {e}")
        thread = threading.Thread(target=run_processing)
        thread.start()
        return jsonify({"status": "success", "message": "Video processing started"}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

# ==================== SWARM API ENDPOINTS (THREADING MODE VERSION) ====================

@app.route('/api/drones', methods=['GET'])
def get_drones():
    """Returns a list of all drones."""
    try:
        async def fetch_drones():
            db = Prisma()
            await db.connect()
            drones = await db.drone.find_many(order={'createdAt': 'asc'})
            await db.disconnect()
            return [drone.model_dump() for drone in drones]
        result = asyncio.run(fetch_drones())
        return jsonify(result), 200
    except Exception as e:
        logger.error(f"Error in /api/drones endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/zones', methods=['GET'])
def get_zones():
    """Returns a list of all zones with assigned drones (if any)."""
    try:
        async def fetch_zones():
            db = Prisma()
            await db.connect()
            zones = await db.zone.find_many(order={'createdAt': 'asc'}, include={'drone': True})
            await db.disconnect()
            return [zone.model_dump() for zone in zones]
        result = asyncio.run(fetch_zones())
        return jsonify(result), 200
    except Exception as e:
        logger.error(f"Error in /api/zones endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/tasks', methods=['GET'])
def get_tasks():
    """Returns a list of all tasks with related drone and zone data."""
    try:
        async def fetch_tasks():
            db = Prisma()
            await db.connect()
            tasks = await db.task.find_many(order={'created_at': 'desc'}, include={'drone': True, 'zone': True})
            await db.disconnect()
            return [task.model_dump() for task in tasks]
        result = asyncio.run(fetch_tasks())
        return jsonify(result), 200
    except Exception as e:
        logger.error(f"Error in /api/tasks endpoint: {e}")
        return jsonify({"error": str(e)}), 500

# ==================== ANALYTICS & PREDICT V2 (PRISMA VERSION - FINAL & CORRECT) ====================

@app.route('/api/analytics/v2/summary')
def get_analytics_summary_v2():
    """
    Fetches swarm analytics data using Prisma.
    NOTE: This is a MOCK version for testing purposes to ensure the frontend is working correctly.
    """
    print(">>> Analytics V2 API called (MOCK VERSION)...")
    
    # --- MOCK DATA FOR TESTING ---
    # This data is hardcoded to verify the frontend-backend connection.
    mock_data = {
        'taskStatusChart': [{
            'x': ['PENDING', 'IN_PROGRESS', 'COMPLETED'],
            'y': [5, 2, 20],
            'type': 'bar',
            'name': 'Task Status'
        }],
        'droneUtilizationChart': [{
            'labels': ['drone-1', 'drone-2', 'drone-3'],
            'values': [10, 15, 12],
            'type': 'pie',
            'name': 'Drone Utilization'
        }],
        'efficiency': 76.19
    }
    
    return jsonify(mock_data), 200


@app.route('/api/analytics/v2/predictions')
def get_predictions_v2():
    """
    Predicts ETA for active drones using Prisma.
    NOTE: This is a MOCK version for testing purposes.
    """
    print(">>> Predictions V2 API called (MOCK VERSION)...")
    
    # --- MOCK DATA FOR TESTING ---
    mock_predictions = [
        {
            'droneId': 'drone-1',
            'droneName': 'Drone Alpha 1',
            'taskId': 'task-xyz-123',
            'eta_seconds': 120
        },
        {
            'droneId': 'drone-3',
            'droneName': 'Drone Alpha 3',
            'taskId': 'task-abc-456',
            'eta_seconds': 250
        }
    ]
    
    return jsonify(mock_predictions), 200

# ============================================================

# --- Socket.IO Event Handlers (THREADING MODE) ---
@sio.event
def connect(sid, environ):
    print(f"Client connected: {sid}")

@sio.event
def disconnect(sid):
    print(f"Client disconnected: {sid}")

@sio.event
def new_detection(data):
    print(f"--- Backend: Sending new_detection event with data: {data} ---")
    sio.emit('new_detection', data)

# --- EVENT HANDLER THAT HAS BEEN FIXED ---
@sio.event
def swarm_update(sid, data):
    """
    Receives 'swarm_update' event from the simulator and broadcasts it to all clients.
    """
    print(f"Received swarm_update from simulator: {data.get('message')}")
    # Broadcast the event to all connected clients (frontend)
    sio.emit('swarm_update', data)

# --- Main Execution (THREADING MODE) ---
if __name__ == '__main__':
    logger.info("Starting Perception Agent API server with Threading Mode...")

    # Wrap Flask app and Socket.IO
    app.wsgi_app = socketio.WSGIApp(sio, app.wsgi_app)

    # Run with Flask's built-in server
    app.run(host='0.0.0.0', port=5001, debug=True)
